local ExecutorChecker = {}
ExecutorChecker.UnsupportedExecutors = {"Xeno", "Solara", "Jjsploit"}
ExecutorChecker.SupportedExecutors = {"Bunni", "Velocity", "Delta", "Krnl"}
ExecutorChecker.GithubScript = "https://raw.githubusercontent.com/weatherwess-lgtm/Azure/refs/heads/main/Source"

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ExecutorCompatibilityCheck"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = game:GetService("CoreGui") or game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")

local mainContainer = Instance.new("Frame")
mainContainer.Size = UDim2.new(0, 450, 0, 300)
mainContainer.Position = UDim2.new(0.5, -225, 0.5, -150)
mainContainer.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
mainContainer.BorderSizePixel = 0
mainContainer.BackgroundTransparency = 0.1
mainContainer.ClipsDescendants = true
mainContainer.Active = true
mainContainer.Draggable = true
mainContainer.Parent = screenGui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 12)
mainCorner.Parent = mainContainer

local mainStroke = Instance.new("UIStroke")
mainStroke.Color = Color3.fromRGB(100, 150, 255)
mainStroke.Thickness = 2
mainStroke.Transparency = 0.3
mainStroke.Parent = mainContainer

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, 0, 0, 50)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "NiGGER CHECKER"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 24
titleLabel.Font = Enum.Font.GothamBold
titleLabel.Parent = mainContainer

local subtitleLabel = Instance.new("TextLabel")
subtitleLabel.Size = UDim2.new(1, 0, 0, 20)
subtitleLabel.Position = UDim2.new(0, 0, 0, 30)
subtitleLabel.BackgroundTransparency = 1
subtitleLabel.Text = "Checking if your a nigger"
subtitleLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
subtitleLabel.TextSize = 14
subtitleLabel.Font = Enum.Font.Gotham
subtitleLabel.Parent = mainContainer

local statusContainer = Instance.new("Frame")
statusContainer.Size = UDim2.new(1, -40, 0, 120)
statusContainer.Position = UDim2.new(0, 20, 0, 70)
statusContainer.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
statusContainer.BorderSizePixel = 0
statusContainer.Parent = mainContainer

local statusCorner = Instance.new("UICorner")
statusCorner.CornerRadius = UDim.new(0, 8)
statusCorner.Parent = statusContainer

local statusText = Instance.new("TextLabel")
statusText.Size = UDim2.new(1, -20, 1, -20)
statusText.Position = UDim2.new(0, 10, 0, 10)
statusText.BackgroundTransparency = 1
statusText.Text = ""
statusText.TextColor3 = Color3.fromRGB(255, 255, 255)
statusText.TextSize = 16
statusText.Font = Enum.Font.Gotham
statusText.TextXAlignment = Enum.TextXAlignment.Left
statusText.TextYAlignment = Enum.TextYAlignment.Top
statusText.TextWrapped = true
statusText.Parent = statusContainer

local progressFrame = Instance.new("Frame")
progressFrame.Size = UDim2.new(0, 120, 0, 20)
progressFrame.Position = UDim2.new(0.5, -60, 0, 200)
progressFrame.BackgroundTransparency = 1
progressFrame.Parent = mainContainer

local dots = {}
for i = 1, 3 do
    local dot = Instance.new("Frame")
    dot.Size = UDim2.new(0, 12, 0, 12)
    dot.Position = UDim2.new(0, (i-1)*25, 0.5, -6)
    dot.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
    dot.BorderSizePixel = 0
    dot.Parent = progressFrame
    
    local dotCorner = Instance.new("UICorner")
    dotCorner.CornerRadius = UDim.new(1, 0)
    dotCorner.Parent = dot
    
    dots[i] = dot
    
    local offset = i * 0.2
    game:GetService("RunService").Heartbeat:Connect(function()
        local t = tick() + offset
        dot.BackgroundTransparency = 0.3 + 0.7 * math.abs(math.sin(t * 3))
    end)
end

local actionButton = Instance.new("TextButton")
actionButton.Size = UDim2.new(0, 200, 0, 40)
actionButton.Position = UDim2.new(0.5, -100, 1, -60)
actionButton.BackgroundColor3 = Color3.fromRGB(65, 105, 225)
actionButton.Text = ""
actionButton.Visible = false
actionButton.Font = Enum.Font.GothamBold
actionButton.TextSize = 16
actionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
actionButton.Parent = mainContainer

local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 8)
buttonCorner.Parent = actionButton

local buttonStroke = Instance.new("UIStroke")
buttonStroke.Color = Color3.fromRGB(100, 150, 255)
buttonStroke.Thickness = 1
buttonStroke.Transparency = 0.5
buttonStroke.Parent = actionButton

local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 30, 0, 30)
closeButton.Position = UDim2.new(1, -35, 0, 5)
closeButton.BackgroundTransparency = 1
closeButton.Text = "✕"
closeButton.TextColor3 = Color3.fromRGB(180, 180, 200)
closeButton.TextSize = 20
closeButton.Font = Enum.Font.GothamBold
closeButton.Parent = mainContainer

closeButton.MouseEnter:Connect(function()
    closeButton.TextColor3 = Color3.fromRGB(255, 100, 100)
end)

closeButton.MouseLeave:Connect(function()
    closeButton.TextColor3 = Color3.fromRGB(180, 180, 200)
end)

closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

local function typeWriter(text, label, speed)
    label.Text = ""
    for i = 1, #text do
        label.Text = string.sub(text, 1, i)
        wait(speed or 0.03)
    end
end

local function detectExecutor()
    local executorName = "Unknown"
    
    if identifyexecutor then
        local success, result = pcall(identifyexecutor)
        if success and result then
            executorName = tostring(result)
        end
    elseif getexecutorname then
        local success, result = pcall(getexecutorname)
        if success and result then
            executorName = tostring(result)
        end
    elseif getgenv and getgenv().executor_name then
        executorName = tostring(getgenv().executor_name)
    end
    
    executorName = executorName:gsub("^%s*(.-)%s*$", "%1") -- trim
    executorName = executorName:gsub("%s+", "") -- remove spaces
    executorName = executorName:gsub("V2", ""):gsub("v2", "") -- remove version tags
    
    return executorName
end

local function isSupported(executorName)
    for _, supported in ipairs(ExecutorChecker.SupportedExecutors) do
        if executorName:lower():find(supported:lower()) then
            return true
        end
    end
    return false
end

local function getUnsupportedReason(executorName)
    local reasons = {
        ["Xeno"] = {
            title = "Xeno Executor - Not Supported",
            reasons = {
                "1. Lacking 'hookmetamethod' implementation - Critical for bypassing remote checks",
                "2. No support for 'getcallingscript' - Required to identify ItemSpawn script context",
                "3. Weak metamethod hooking - Cannot properly intercept __index calls",
                "4. Limited debug library - Missing essential function manipulation capabilities",
                "5. No 'newcclosure' support - Cannot create secure closures for hooks",
                "6. Incomplete 'rawequal' implementation - Fails secure comparisons",
                "7. Missing 'checkcaller' detection - Cannot differentiate executor vs game calls",
                "8. Poor closure environment handling - newcclosure compatibility issues",
                "9. No 'getnamecallmethod' support - Remote event bypass impossible",
                "10. Weak thread safety - Race conditions in metamethod hooks",
                "11. Incomplete bytecode transpiler - Some Lua features fail silently",
                "12. Missing 'getgenv' pollution control - Cannot isolate script environment",
                "13. No 'fireproximityprompt' implementation - Cannot interact with items",
                "14. Limited function decompilation - Cannot debug complex closures",
                "15. Outdated Roblox API support - Missing newer Luau features"
            },
            mocking = "Xeno tries so hard to be a premium executor but can't even handle basic metamethod hooks. Stick to simple scripts, kiddo. Even their 'advanced' features are just renamed basic functions. The entire executor is held together by wishful thinking and Stack Overflow copy-pasting."
        },
        ["Solara"] = {
            title = "Solara Executor - Not Supported",
            reasons = {
                "1. Incomplete 'hookmetamethod' implementation - Fails on complex metamethod chains",
                "2. No 'checkcaller' detection - Cannot differentiate between script and executor calls",
                "3. Weak '__namecall' interception - Remote event bypass will fail",
                "4. Missing 'rawequal' optimization - Cannot perform secure comparisons",
                "5. Poor closure environment handling - newcclosure compatibility issues",
                "6. Limited debug.getinfo support - Cannot inspect function call stacks",
                "7. No 'getcallingscript' implementation - Cannot identify calling context",
                "8. Weak Luau type handling - Fails on strict type checking",
                "9. Missing 'getrenv' access - Cannot access Roblox environment properly",
                "10. Incomplete sandbox implementation - Security holes cause crashes",
                "11. No 'getgc' support - Cannot scan for game objects",
                "12. Weak metamethod restoration - Cannot properly unhook functions",
                "13. Missing 'isexecutorclosure' detection - Cannot verify closure origin",
                "14. Limited coroutine manipulation - Fails on complex threading",
                "15. Poor error handling - Silent failures make debugging impossible"
            },
            mocking = "Solara is like that kid who copies homework but still fails the test. All the features are there, just... broken. Their 'custom' implementation is just a fork of a three-year-old open-source project with a fresh coat of paint. The entire executor is duct tape and prayers."
        },
        ["Jjsploit"] = {
            title = "JJSploit - Not Supported (And Never Will Be)",
            reasons = {
                "1. NO metamethod hooking whatsoever - 'hookmetamethod' completely absent",
                "2. Missing 'getcallingscript' - Cannot access calling script context",
                "3. No 'getnamecallmethod' - Remote event manipulation impossible",
                "4. Lacks 'checkcaller' - Cannot create secure bypasses",
                "5. No 'newcclosure' support - Failed closure creation",
                "6. Missing 'fireproximityprompt' - Cannot interact with items",
                "7. Weak debug library - No function inspection capabilities",
                "8. Poor execution environment - High detection rate",
                "9. Outdated API - Uses deprecated Roblox functions",
                "10. General incompetence - The entire executor is held together by duct tape",
                "11. No 'rawequal' implementation - Cannot perform secure comparisons",
                "12. Missing 'getrenv'/'getgenv' distinction - Environment pollution",
                "13. Weak bytecode loading - Crashes on complex scripts",
                "14. No 'identifyexecutor' function - Cannot even identify itself",
                "15. Literally uses a free public API key - Your execution is logged publicly"
            },
            mocking = "JJSploit is so weak that even ROBLOX's built-in anti-cheat detects it. You're better off using the Developer Console. Seriously, uninstall this garbage and get a real executor. Your PC is crying. The developers are probably laughing at you while they mine crypto with your computer. JJSploit is the equivalent of trying to hack NASA with a TI-84 calculator. It's so outdated, it probably still uses Internet Explorer as its user agent. Every time you execute with JJSploit, a senior developer somewhere has an aneurysm. The only thing JJSploit excels at is disappointing your parents and making your system vulnerable to actual malware. Get a real executor, or better yet, learn to script properly instead of downloading the first thing that appears in a YouTube tutorial from 2019."
        },
        ["Unknown"] = {
            title = "Unknown Executor - Not Supported",
            reasons = {
                "1. Cannot identify executor capabilities - Failed name detection",
                "2. Unknown metamethod support - Cannot verify hooking capabilities",
                "3. Uncertain debug library implementation - Function manipulation unknown",
                "4. Unverified closure system - newcclosure compatibility unclear",
                "5. Try using a supported executor: Bunni, Velocity, Delta, or Krnl",
                "6. Missing 'hookmetamethod' - Critical for anti-cheat bypass",
                "7. No 'getcallingscript' detection - Cannot verify script context",
                "8. Unknown 'checkcaller' support - Cannot secure function calls",
                "9. Uncertain 'rawequal' implementation - Secure comparisons may fail",
                "10. No 'getnamecallmethod' - Remote event manipulation risky",
                "11. Missing 'fireproximityprompt' - Cannot interact with game objects",
                "12. Unknown environment isolation - May conflict with game scripts",
                "13. Uncertain Luau compatibility - Type checking may fail",
                "14. No 'newcclosure' verified - Closure creation unpredictable",
                "15. Try re-executing or using a recognized supported executor"
            },
            mocking = "Your executor is so unknown, even it doesn't know what it is. Might be time for an upgrade, friend. Whatever you're using is probably just a reskin of JJSploit with extra malware. Seriously, if the executor can't even identify itself, how can you trust it to run complex bypasses? It's like trying to race in the Indy 500 with a car made of cardboard and hope."
        }
    }
    
    for name, data in pairs(reasons) do
        if executorName:lower():find(name:lower()) then
            return data
        end
    end
    
    return reasons["Unknown"]
end

local function showExplanation(executorName)
    local explanation = getUnsupportedReason(executorName)
    
    local explanationWindow = Instance.new("Frame")
    explanationWindow.Size = UDim2.new(0, 500, 0, 400)
    explanationWindow.Position = UDim2.new(0.5, -250, 0.5, -200)
    explanationWindow.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    explanationWindow.BorderSizePixel = 0
    explanationWindow.Parent = screenGui
    
    local expCorner = Instance.new("UICorner")
    expCorner.CornerRadius = UDim.new(0, 12)
    expCorner.Parent = explanationWindow
    
    local expStroke = Instance.new("UIStroke")
    expStroke.Color = Color3.fromRGB(255, 100, 100)
    expStroke.Thickness = 2
    expStroke.Parent = explanationWindow
    
    local expTitle = Instance.new("TextLabel")
    expTitle.Size = UDim2.new(1, 0, 0, 40)
    expTitle.BackgroundTransparency = 1
    expTitle.Text = explanation.title
    expTitle.TextColor3 = Color3.fromRGB(255, 100, 100)
    expTitle.TextSize = 20
    expTitle.Font = Enum.Font.GothamBold
    expTitle.Parent = explanationWindow
    
    local reasonsList = Instance.new("ScrollingFrame")
    reasonsList.Size = UDim2.new(1, -20, 1, -100)
    reasonsList.Position = UDim2.new(0, 10, 0, 50)
    reasonsList.BackgroundTransparency = 1
    reasonsList.BorderSizePixel = 0
    reasonsList.ScrollBarThickness = 6
    reasonsList.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 120)
    reasonsList.CanvasSize = UDim2.new(0, 0, 0, 0)
    reasonsList.AutomaticCanvasSize = Enum.AutomaticSize.Y
    reasonsList.Parent = explanationWindow
    
    local reasonsUI = Instance.new("UIListLayout")
    reasonsUI.Padding = UDim.new(0, 5)
    reasonsUI.Parent = reasonsList
    
    for _, reason in ipairs(explanation.reasons) do
        local reasonLabel = Instance.new("TextLabel")
        reasonLabel.Size = UDim2.new(1, 0, 0, 30)
        reasonLabel.BackgroundTransparency = 1
        reasonLabel.Text = "• " .. reason
        reasonLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        reasonLabel.TextSize = 14
        reasonLabel.Font = Enum.Font.Gotham
        reasonLabel.TextXAlignment = Enum.TextXAlignment.Left
        reasonLabel.TextWrapped = true
        reasonLabel.AutomaticSize = Enum.AutomaticSize.Y
        reasonLabel.Parent = reasonsList
    end
    
    local mockingTitle = Instance.new("TextLabel")
    mockingTitle.Size = UDim2.new(1, 0, 0, 30)
    mockingTitle.BackgroundTransparency = 1
    mockingTitle.Text = "Why this executor fails: Jokes aside every executor is good"
    mockingTitle.TextColor3 = Color3.fromRGB(255, 150, 150)
    mockingTitle.TextSize = 16
    mockingTitle.Font = Enum.Font.GothamBold
    mockingTitle.TextXAlignment = Enum.TextXAlignment.Left
    mockingTitle.Parent = reasonsList
    
    local mockingBox = Instance.new("TextBox")
    mockingBox.Size = UDim2.new(1, -10, 0, 100)
    mockingBox.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    mockingBox.BackgroundTransparency = 0.3
    mockingBox.Text = explanation.mocking
    mockingBox.TextColor3 = Color3.fromRGB(255, 200, 200)
    mockingBox.TextSize = 13
    mockingBox.Font = Enum.Font.Gotham
    mockingBox.TextWrapped = true
    mockingBox.MultiLine = true
    mockingBox.ClearTextOnFocus = false
    mockingBox.Parent = reasonsList
    
    local mockingCorner = Instance.new("UICorner")
    mockingCorner.CornerRadius = UDim.new(0, 6)
    mockingCorner.Parent = mockingBox
    
    local closeExp = Instance.new("TextButton")
    closeExp.Size = UDim2.new(0, 100, 0, 30)
    closeExp.Position = UDim2.new(1, -110, 1, -40)
    closeExp.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
    closeExp.Text = "Close"
    closeExp.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeExp.TextSize = 14
    closeExp.Font = Enum.Font.GothamBold
    closeExp.Parent = explanationWindow
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 6)
    closeCorner.Parent = closeExp
    
    closeExp.MouseButton1Click:Connect(function()
        explanationWindow:Destroy()
    end)
    
    explanationWindow.Position = UDim2.new(0.5, -250, 0, -400)
    explanationWindow:TweenPosition(
        UDim2.new(0.5, -250, 0.5, -200),
        Enum.EasingDirection.Out,
        Enum.EasingStyle.Back,
        0.5,
        true
    )
end

local function runCompatibilityCheck()
    mainContainer.Position = UDim2.new(0.5, -225, 0, -300)
    mainContainer:TweenPosition(
        UDim2.new(0.5, -225, 0.5, -150),
        Enum.EasingDirection.Out,
        Enum.EasingStyle.Back,
        0.6,
        true
    )
    
    wait(0.5)
    
    typeWriter("Checking Executor...", statusText, 0.04)
    wait(1.2)
    
    local executorName = detectExecutor()
    typeWriter("Executor Checked: " .. executorName, statusText, 0.03)
    wait(1)
    
    typeWriter("Checking compatibility...", statusText, 0.04)
    wait(1.5)
    
    local supported = isSupported(executorName)
    
    if supported then
        typeWriter("EXECUTOR SUPPORTED! You may proceed.", statusText, 0.02)
        statusText.TextColor3 = Color3.fromRGB(100, 255, 100)
        mainStroke.Color = Color3.fromRGB(100, 255, 100)
        
        wait(1)
        
        typeWriter("Loading Azure YBA Script...", statusText, 0.03)
        wait(0.5)
        
        local success, err = pcall(function()
            loadstring(game:HttpGet(ExecutorChecker.GithubScript))()
        end)
        
        if success then
            statusText.Text = "Script executed successfully!"
        else
            statusText.Text = "Error loading script: " .. tostring(err)
            statusText.TextColor3 = Color3.fromRGB(255, 100, 100)
        end
        
        wait(2)
        screenGui:Destroy()
    else
        typeWriter("EXECUTOR NOT SUPPORTED", statusText, 0.02)
        statusText.TextColor3 = Color3.fromRGB(255, 100, 100)
        mainStroke.Color = Color3.fromRGB(255, 100, 100)
        
        wait(1)
        
        actionButton.Visible = true
        actionButton.Text = "Check why?"
        actionButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        
        actionButton.Size = UDim2.new(0, 0, 0, 40)
        actionButton:TweenSize(
            UDim2.new(0, 200, 0, 40),
            Enum.EasingDirection.Out,
            Enum.EasingStyle.Elastic,
            0.6,
            true
        )
        
        actionButton.MouseButton1Click:Connect(function()
            showExplanation(executorName)
        end)
    end
end

runCompatibilityCheck()
